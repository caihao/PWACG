# Tutorial

### Program Running Environment Configuration

- **ROOT installation**

    For any Linux distribution and MacOS, ROOT is available as a [conda package](https://anaconda.org/conda-forge/root/). To create a new conda environment containing ROOT and activate it, execute:
    
    ```python
    $ conda config --set channel_priority strict 
    $ conda create --name <my-environment> python=3.9 # Choose a suitable python version
    $ conda activate <my-environment>
    $ conda install -c conda-forge root
    ```

    Setting `channel_priority` to `strict` is required to avoid conflicts on some platforms, see [the relevant conda docs](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-channels.html#strict-channel-priority) for more information.

    The conda package uses C++17.

    More instructions about using this package are available in [this blog post](https://iscinumpy.gitlab.io/post/root-conda/).

    Please report any issues with the conda package [here](https://github.com/conda-forge/root-feedstock).

- **JAX Conda installation**
    - Official readme install
        [GitHub - google/jax: Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more](https://github.com/google/jax)
        [Installing JAX — JAX documentation](https://jax.readthedocs.io/en/latest/installation.html)
- **Other packages**
    - jinja2
    - numpy
    - scipy 
    - pandas
    - SciencePlots
        ```bash
        $ python -m pip install git+https://github.com/garrettj403/SciencePlots.git
        ```
        [SciencePlots Format Matplotlib for scientific plotting](https://pypi.org/project/SciencePlots/1.0.2/)

### PWACG Usage Manual 

#### Steps to Run Fitting Program

- Run code generation script
    > The configuration files used for code generation are in the `config` path. The specific parameter adjustment method can be seen in the following -> Parameter Adjustment Method
    ```bash
    $ python create_all_scripts.py
    ```
- Run fitting program 
    > Taking the fit $\psi(2s) \rightarrow \phi KK$ as an example
    ```bash 
    $ python run/fit_kk.py
    ```
- Run plotting program
    1. Run the code generation script again, because the plotting script is also generated by code
        ```bash
        $ python create_all_scripts.py
        ```
    2. Generate data needed for plotting
        > Since the result of the fit is the parameters of the likelihood function, if you want to display the fit result intuitively, you can calculate the weight of the MC by inputting the MC data into the likelihood function, and then by adding the weight to the MC histogram to make the MC data have the shape of the fit result. This step is used to generate the weight!
        ```bash
        $ python run/draw_wt_kk.py
        ```
    3. Plotting
        > Plotting results are saved in `result_repo/xxxx/pictures/partial_mods_pictures`, where `xxxx` is the timestamp.
        ```bash
        $ python run/dplot_run_kk.py  
        ```

#### Parameter Adjustment Method

> Note! After adjusting the parameters, be sure to run the code generation script again to make the parameter adjustment take effect by running the code generation script.

> The `json` files used for parameter adjustment are all in the `config` directory. Here we use the fit $\psi(2s) \rightarrow \phi KK$ as an example.

- **config/generator_kk.json**
    - Configuration file for code generation
    - Function of each key in the configuration file:
        - `id` configuration script id
        - `jinja_fit_info` inside, it is divided into several categories according to functional modules, such as fitting script "fit", batch job submission script "batch", etc. These modules save the templates used for code generation and the paths of the generated scripts and output, as well as the paths to save the result files of the corresponding functions.
        - `jinja_draw_info` similar to `jinjia_fit_info`, but this is for plotting-related paths.
        - `json_pwa` path of the partial wave analysis model configuration file.
        - The above paths generally do not need to be modified.
        - `annex_info` pay attention to the "fit" module:
            - `use_weight` whether to use real data with weight correction
            - `write` whether to save the fit result to a file
            - `Cycles` number of fit repetitions, with no correlation between each repetition
            - `total_frac` target fraction value for fraction constraint
            - `boundary` whether to use the parameter boundary constraint function
            - `lambda_tfc` strength of fraction constraint
            - `random` whether to add random offset to initial parameters at the start of each fit
- **config/parameters.json**
    > Configuration file for multi-thread and multi-GPU parameters
    - Function of each key in the configuration file:
        - `parameters` configuration interface for multi-GPU and multi-thread scheduling
            - base All other modules can inherit parameters from base. If a certain module (e.g., "fit") needs to adjust a certain parameter, it can be overwritten under that block, and the latest parameter will be used.
                > We have currently implemented multi-card computation on a single machine, using a data parallel approach!
                - *run_config*: configuration for running multi-process and multi-thread on multiple GPUs (set as default)
                    - total_gpu_id: e.g., [0, 1], tells the program that there are two GPUs on the computer, and their IDs are cuda:0 and cuda:1
                    - processes_gpus: number of GPUs that can be used in one process
                    - max_processes: maximum number of processes, if it is 1, it is a single process
                    - max_processes_memory: maximum memory occupied by each process
                    - thread_gpus: number of GPUs that a thread can use
                    - threads_in_one_gpu: number of threads running on one GPU
                - *data_config*: data slicing, for the purpose of data parallelism when running on multiple GPUs.
                    - data_slices: number of slices to divide the data into
                    - mc_slices:
                    - mini_run:
        - `draw_config` setting for plotting parameters
        - `CacheTensor` setting for precomputed tensor calculation module
- **config/pwa_info_kk.json**
    > Key configuration file, where the partial wave analysis model is set!
    - Using pwa_info_kk.json as an example
    - mod_info: each partial wave becomes a mod, mod_info is a list. The list of resonances that can be added [resonances for phikk and phipipi](resonances_for_phikk_and_phipipi.md)
        - Taking one of the mods in mod_info as an example: setting parameter ranges [method of adding parameter ranges](method_of_adding_parameter_ranges.md)
            ```json
            {
                "mod": "phif0_980_kk",
                # Name of the partial wave, phif0 is the amplitude name, 980 indicates the f0(980) resonance

                "amp": "phif0_kk",
                # Amplitude used by the partial wave

                "prop": {
                    "prop_phi": {
                        "name": "BW",
                        "paras": [
                            "phi_mass",
                            "phi_width",
                            "phi_kk"
                        ]
                    },
                # Propagator setting for the phi part
                "prop_f": {
                        "name": "flatte980", 
                        "paras": [
                            "kk_f980_mass",
                            "kk_f980_g_kk",
                            "kk_f980_rg",
                            "f_kk"
                        ]
                    }
                },
                # Propagator setting for the f part

                "Sbc": {
                    "phi": "phi_kk",
                    "f": "f_kk"
                },
                # Input names of intermediate resonances

                "args": {
                    "phi_m": {
                        "value": 1.02, # Initial value
                        "name": "phi_mass",
                        "fix": true, # Whether to set as a fixed value
                        "error": 0.0  # This does not matter, does not affect the fit
                    },
                    "phi_w": {
                        "value": 0.004,
                        "name": "phi_width", 
                        "fix": true,
                        "error": 0.0
                    },
                    # The mass and width of phi are fixed and do not need to be fitted
                    "kk_f980_m": {
                        "value": 0.9791907429163911,
                        "name": "kk_f980_mass",
                        "range": [
                            0.98,
                            10.0
                        ],
                        # Set range [center value, constraint strength]
                        "error": 0.0018985343438633919
                    },
                    "kk_g_kk": {
                        "value": -0.09047962086358292,
                        "name": "kk_f980_g_kk",
                        "error": 0.0056502434500060265
                    },
                    "kk_rg": {
                        "value": 7.954832705543948,
                        "name": "kk_f980_rg",
                        "error": 0.8648589371836074
                    },
                    # kk_f980_m, kk_g_kk and kk_rg are the parameters of the flatte980 propagator in prop_f
                    # Except for f980 which uses flatte980, most partial waves use the ordinary Breit–Wigner,
                    # Breit–Wigner parameters use mass and width.
                    "kk_f980_c1": {
                        "value": 0.1,
                        "name": "kk_f980_const",
                        "fix": true,
                        "error": 0.0
                    },
                    "kk_f980_c2": {
                        "value": 0.10272328310095176,
                        "name": "kk_f980_const",
                        "error": 0.002280967551017021
                    },
                    "kk_f980_t1": {
                        "value": 0.1,
                        "name": "kk_f980_theta",
                        "fix": true,
                        "error": 0.0
                    },
                    "kk_f980_t2": {
                        "value": 0.039981856462107265,
                        "name": "kk_f980_theta", 
                        "error": 0.0018185031895430884
                    }
                }
            }
            ```

#### Batch Running

> **Super useful batch running script!**

- Run
    ```bash  
    $ python run/batch_kk.py
    ```
- Select batch function by modifying `templates/batch_run_template.py`, here the function for batch job submission on a supercomputer is used
    ```python
    if __name__ == '__main__':
        # cal_sig = batch_object.calculate_significance("config/generator_{{generator_id}}.json")
        # cal_sig.cycle_calculate()

        cal_sig = batch_object.submit("config/generator_{{generator_id}}.json")
        cal_sig.submit()

        # cal_scan = batch_object.scan("config/generator_{{generator_id}}.json")
        # cal_scan.Loop()
        # cal_scan.scan_lh()
        # cal_scan.scan_frac()
        # cal_scan.cal_fraction_error()
        # cal_scan.stepBYstep()
        # cal_scan.draw_all()
        # cal_scan.Iterate()

        # cal_sig = batch_object.calculate_branch("config/generator_{{generator_id}}.json") 
        # cal_sig.cal_branch()

        # cal_sig = batch_object.sort_table()
    ```
    - Function list:
        - Batch submit jobs to supercomputer submit
            - In `templates/batch_template.py`, modify the value of `self.cgpwa_dir` to the absolute path of PWACG on the supercomputer
                ```python
                class submit(base_batch):
                    def __init__(self, generator_path):
                        super().__init__(generator_path)
                        self.generator_init(self.generator_dict)
                        self.initial_prepare()
                        self.read_pwa("fit")
                        self.cgpwa_dir = "/project/xxxx/PWACG/"#modify this to the corresponding path
                ```
        - Batch run scan-type jobs scan
        - The files batch_script/xxxx-pwa.sbatch, batch_script/xxxx-pwa.sbatch.conda, batch_script/xxxx-pwa.sbatch.singularity need some modifications:
            - batch/xxxx-pwa.sbatch
                ```python  
                singularity exec --nv --bind /project/whoami,/scratch/whoami /scratch/xxxx/singularity/jax.sif python3 {{run_file}}
                ```
            - batch/xxxx-pwa.sbatch.conda
                ```python
                source /home/xxxx/project/xxxx/anaconda3/bin/activate
                # conda activate jax_env remove this

                ```
            - pwa.sbatch.singularity
                ```python
                singularity exec --nv --bind /project/`whoami`,/scratch/`whoami` /scratch/xxxx/singularity/jax.sif python3 {{run_file}}
                ```
- **Batch Running Script Parameter Modification**
    - Scan fraction range in ./template/batch_template.py
        ```python
        def submit(self):
                print("begain to submit job to slurm")
                
                frac_tfc = onp.arange(1.1,1.4,0.05) #modify range here

                # with open("output/fit/fit_result_kk/fit_result_kk_2/result_info.json",encoding='utf-8') as f:
                #     mydict = json.loads(f.read())
                # arr_lh = onp.array([float(mydict["result_"+str(j)]["fcn"]) for j in range(60)])
                # min_index = list(onp.where(arr_lh == arr_lh.min()))[0][0]

                # for N, tfc in enumerate(frac_tfc):
                #     for n, scanX in mod_info:
                #         self.generatorJob(N,tfc,n,scanX)

                for n, scanX in enumerate(frac_tfc):
                    self.ordinaryJob(n,scanX)
        ```
- **Image Drawing**

    Run templates/scan_draw.py in the corresponding virtual environment locally.

    **Note:** The plotting parameters in scan_draw.py also need to be modified according to the fraction range, and the path to save the fit results also needs to be modified.
    ```python
    def read_scan_tfc_result(filename):
        target_character = "the minist value "
        R0_fcn = list()
        for _n, n in enumerate(frac_tfc):
            R0_fcn.append(find_character_in_file("./R_1"+filename+"/fit_result_"+str(_n)+"/fit_{0}.log".format(_n), target_character))
         #Modify this and the scanSF_dir_list below to the current path for saving fit results
        #filename=scanSF_dir_list
        draw_R0 = Draw(frac_tfc,R0_fcn)
        return draw_R0
    ```